#!/usr/bin/env python3
"""Generate roadmap PR artifacts from local telemetry."""

from __future__ import annotations

import argparse
from datetime import date
import json
from pathlib import Path
import subprocess
import sys
from typing import Any, Dict, List, Tuple


class RoadmapPrepError(Exception):
    pass


def _parse_csv(raw: str) -> List[str]:
    seen = set()
    out: List[str] = []
    for part in raw.split(","):
        item = part.strip()
        if not item:
            continue
        if item in seen:
            continue
        seen.add(item)
        out.append(item)
    return out


def _run(cmd: List[str], cwd: Path) -> Tuple[int, str, str]:
    try:
        proc = subprocess.run(cmd, cwd=cwd, capture_output=True, text=True, check=False)
    except Exception as err:
        return 99, "", str(err)
    return int(proc.returncode), proc.stdout or "", proc.stderr or ""


def _load_json(path: Path) -> Dict[str, Any]:
    try:
        obj = json.loads(path.read_text(encoding="utf-8"))
    except Exception as err:
        raise RoadmapPrepError(f"invalid json file {path}: {err}") from err
    if not isinstance(obj, dict):
        raise RoadmapPrepError(f"json file must be object: {path}")
    return obj


def _summary_markdown(rollup: Dict[str, Any], stamp: str) -> str:
    lines = []
    lines.append(f"# Roadmap Update ({stamp})")
    lines.append("")
    lines.append("## Top Priority Skills")
    for i, skill in enumerate(rollup.get("roadmap_priority", [])[:10], start=1):
        lines.append(f"{i}. {skill}")
    lines.append("")
    lines.append("## Skills Snapshot")
    for row in rollup.get("skills", [])[:20]:
        if not isinstance(row, dict):
            continue
        lines.append(
            f"- {row.get('skill')}: success_rate={row.get('success_rate')} invocations={row.get('invocations')} avg_ms={row.get('avg_duration_ms')}"
        )
    lines.append("")
    return "\n".join(lines) + "\n"


def _normalize_stamp(raw: str) -> str:
    value = raw.strip()
    if not value:
        return date.today().isoformat()
    try:
        date.fromisoformat(value)
    except ValueError as err:
        raise RoadmapPrepError(f"invalid --stamp date: {raw}") from err
    return value


def _pr_body(report: Dict[str, Any], rollup_path: Path, summary_path: Path, repo_root: Path) -> str:
    top = report.get("top_priority", [])
    if not isinstance(top, list):
        top = []
    try:
        rel_rollup = rollup_path.relative_to(repo_root)
    except ValueError:
        rel_rollup = rollup_path
    try:
        rel_summary = summary_path.relative_to(repo_root)
    except ValueError:
        rel_summary = summary_path

    lines = []
    lines.append("<!-- roadmap-pr-prep:daily-roadmap -->")
    lines.append("## Daily Roadmap Update")
    lines.append("")
    lines.append(f"Artifacts:")
    lines.append(f"- `{rel_rollup}`")
    lines.append(f"- `{rel_summary}`")
    lines.append("")
    only_skills = report.get("only_skills", [])
    if isinstance(only_skills, list) and only_skills:
        lines.append("Scoped to changed skills:")
        for skill in only_skills:
            lines.append(f"- {skill}")
        lines.append("")
    lines.append("Top priority skills:")
    for i, skill in enumerate(top[:10], start=1):
        lines.append(f"{i}. {skill}")
    lines.append("")
    lines.append("Generated by `roadmap-pr-prep` with deterministic branch + body.")
    lines.append("")
    return "\n".join(lines)


def _filter_rollup_for_only(rollup: Dict[str, Any], only_skills: List[str]) -> Dict[str, Any]:
    if not only_skills:
        return rollup
    rows = rollup.get("skills", [])
    if not isinstance(rows, list):
        rows = []

    by_skill: Dict[str, Dict[str, Any]] = {}
    for row in rows:
        if not isinstance(row, dict):
            continue
        skill = row.get("skill")
        if isinstance(skill, str):
            by_skill[skill] = row

    filtered_rows: List[Dict[str, Any]] = []
    for skill in only_skills:
        if skill in by_skill:
            filtered_rows.append(by_skill[skill])
            continue
        filtered_rows.append(
            {
                "skill": skill,
                "latest_version": None,
                "latest_bump": None,
                "latest_release_utc": None,
                "latest_summary": "no release/usage rows found in current data",
                "invocations": 0,
                "success_rate": 0.0,
                "avg_duration_ms": 0.0,
            }
        )

    full_priority = rollup.get("roadmap_priority", [])
    ordered_priority: List[str] = []
    if isinstance(full_priority, list):
        for skill in full_priority:
            if not isinstance(skill, str):
                continue
            if skill in only_skills and skill not in ordered_priority:
                ordered_priority.append(skill)
    for skill in only_skills:
        if skill not in ordered_priority:
            ordered_priority.append(skill)

    out = dict(rollup)
    out["skills"] = filtered_rows
    out["roadmap_priority"] = ordered_priority[:20]
    return out


def _open_or_update_pr(
    repo_root: Path,
    branch: str,
    base_branch: str,
    title: str,
    body: str,
    commit_message: str,
    paths: List[Path],
    dry_run: bool,
    skip_pr_if_no_change: bool,
) -> Dict[str, Any]:
    rc, out, err = _run(["git", "rev-parse", "--is-inside-work-tree"], cwd=repo_root)
    if rc != 0 or out.strip() != "true":
        raise RoadmapPrepError("repo_root is not a git repository")

    rc, out, err = _run(["git", "checkout", "-B", branch], cwd=repo_root)
    if rc != 0:
        raise RoadmapPrepError(f"git checkout failed: {err or out}")

    add_cmd = ["git", "add", "--"] + [str(p) for p in paths]
    rc, out, err = _run(add_cmd, cwd=repo_root)
    if rc != 0:
        raise RoadmapPrepError(f"git add failed: {err or out}")

    rc, staged, err = _run(["git", "diff", "--cached", "--name-only"], cwd=repo_root)
    if rc != 0:
        raise RoadmapPrepError(f"git diff --cached failed: {err or staged}")
    has_changes = bool(staged.strip())
    if not has_changes and skip_pr_if_no_change:
        return {
            "mode": "skipped_no_changes",
            "number": 0,
            "url": "",
            "has_changes": False,
            "dry_run": dry_run,
        }

    rc, out, err = _run(["gh", "--version"], cwd=repo_root)
    if rc != 0:
        raise RoadmapPrepError(f"gh CLI unavailable: {err or out}")

    if has_changes and not dry_run:
        rc, out, err = _run(["git", "commit", "-m", commit_message], cwd=repo_root)
        if rc != 0:
            raise RoadmapPrepError(f"git commit failed: {err or out}")

    if not dry_run:
        rc, out, err = _run(["git", "push", "-u", "origin", branch], cwd=repo_root)
        if rc != 0:
            raise RoadmapPrepError(f"git push failed: {err or out}")

    rc, out, err = _run(
        ["gh", "pr", "list", "--state", "open", "--head", branch, "--base", base_branch, "--json", "number,url,title"],
        cwd=repo_root,
    )
    if rc != 0:
        raise RoadmapPrepError(f"gh pr list failed: {err or out}")
    try:
        prs = json.loads(out) if out.strip() else []
    except Exception as parse_err:
        raise RoadmapPrepError(f"invalid gh pr list output: {parse_err}") from parse_err
    if not isinstance(prs, list):
        prs = []

    if prs:
        pr = prs[0] if isinstance(prs[0], dict) else {}
        pr_number = pr.get("number")
        if pr_number is None:
            raise RoadmapPrepError("gh pr list returned invalid number")
        if not dry_run:
            rc, out, err = _run(
                ["gh", "pr", "edit", str(pr_number), "--title", title, "--body", body, "--base", base_branch],
                cwd=repo_root,
            )
            if rc != 0:
                raise RoadmapPrepError(f"gh pr edit failed: {err or out}")
        return {
            "mode": "updated",
            "number": int(pr_number),
            "url": str(pr.get("url", "")),
            "has_changes": has_changes,
            "dry_run": dry_run,
        }

    if dry_run:
        return {
            "mode": "create_pending",
            "number": 0,
            "url": "",
            "has_changes": has_changes,
            "dry_run": True,
        }

    rc, out, err = _run(
        ["gh", "pr", "create", "--head", branch, "--base", base_branch, "--title", title, "--body", body],
        cwd=repo_root,
    )
    if rc != 0:
        raise RoadmapPrepError(f"gh pr create failed: {err or out}")
    pr_url = out.strip().splitlines()[-1] if out.strip() else ""
    return {
        "mode": "created",
        "number": 0,
        "url": pr_url,
        "has_changes": has_changes,
        "dry_run": False,
    }


def run(
    repo_root: Path,
    output_dir: Path,
    open_pr: bool,
    base_branch: str,
    branch_prefix: str,
    dry_run: bool,
    skip_pr_if_no_change: bool,
    only_skills: List[str],
    releases_override: Path | None,
    events_override: Path | None,
    stamp_override: str,
) -> Dict[str, Any]:
    releases = releases_override if releases_override is not None else repo_root / "data" / "skill_releases.jsonl"
    events = events_override if events_override is not None else repo_root / "data" / "skill_usage_events.jsonl"
    if releases_override is None and not releases.exists():
        fallback_releases = repo_root / "skill-adoption-analytics" / "tests" / "fixtures" / "rollup_releases.jsonl"
        if fallback_releases.exists():
            releases = fallback_releases
    schema = repo_root / "skill-adoption-analytics" / "references" / "roadmap_rollup.schema.json"
    rollup_script = repo_root / "skill-adoption-analytics" / "scripts" / "generate_daily_rollup.py"

    if not releases.exists():
        raise RoadmapPrepError(f"missing releases file: {releases}")
    if not events.exists():
        raise RoadmapPrepError(f"missing events file: {events}")
    releases_cmd = releases.resolve()
    events_cmd = events.resolve()

    output_dir.mkdir(parents=True, exist_ok=True)
    stamp = _normalize_stamp(stamp_override)
    rollup_out = output_dir / f"roadmap_rollup_{stamp}.json"
    md_out = output_dir / f"roadmap_summary_{stamp}.md"

    cmd = [
        "python3",
        str(rollup_script),
        "--releases",
        str(releases_cmd),
        "--events",
        str(events_cmd),
        "--schema",
        str(schema),
        "--output",
        str(rollup_out),
    ]
    rc, out, err = _run(cmd, cwd=repo_root)
    if rc != 0:
        raise RoadmapPrepError(f"rollup generation failed: {err or out}")

    rollup = _load_json(rollup_out)
    rollup = _filter_rollup_for_only(rollup, only_skills=only_skills)
    rollup_out.write_text(json.dumps(rollup, indent=2) + "\n", encoding="utf-8")
    md_out.write_text(_summary_markdown(rollup, stamp=stamp), encoding="utf-8")

    report: Dict[str, Any] = {
        "schema_version": 1,
        "stamp": stamp,
        "rollup_path": str(rollup_out),
        "summary_md_path": str(md_out),
        "top_priority": list(rollup.get("roadmap_priority", []))[:10],
        "only_skills": list(only_skills),
        "open_pr": {
            "requested": bool(open_pr),
            "mode": "skipped",
            "url": "",
            "branch": "",
            "base": base_branch,
            "dry_run": bool(dry_run),
        },
    }

    if open_pr:
        if not branch_prefix.startswith("codex/"):
            raise RoadmapPrepError("branch-prefix must start with codex/")
        try:
            rollup_out.relative_to(repo_root)
            md_out.relative_to(repo_root)
        except ValueError as err:
            raise RoadmapPrepError("--open-pr requires output-dir within repo-root") from err
        branch = f"{branch_prefix}-{stamp}"
        title = f"roadmap: daily update {stamp}"
        body = _pr_body(report, rollup_path=rollup_out, summary_path=md_out, repo_root=repo_root)
        pr_info = _open_or_update_pr(
            repo_root=repo_root,
            branch=branch,
            base_branch=base_branch,
            title=title,
            body=body,
            commit_message=f"roadmap: daily update {stamp}",
            paths=[rollup_out, md_out],
            dry_run=dry_run,
            skip_pr_if_no_change=skip_pr_if_no_change,
        )
        report["open_pr"] = {
            "requested": True,
            "mode": pr_info.get("mode", "unknown"),
            "url": pr_info.get("url", ""),
            "branch": branch,
            "base": base_branch,
            "dry_run": bool(dry_run),
            "has_changes": bool(pr_info.get("has_changes", False)),
        }

    return report


def parse_args(argv: List[str]) -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Prepare roadmap PR artifacts")
    p.add_argument("--repo-root", required=True, help="Path to repo root")
    p.add_argument("--output-dir", default="", help="Optional output dir (default: data/roadmap)")
    p.add_argument("--releases", default="", help="Optional releases JSONL override")
    p.add_argument("--events", default="", help="Optional usage events JSONL override")
    p.add_argument("--stamp", default="", help="Optional deterministic date stamp (YYYY-MM-DD)")
    p.add_argument("--open-pr", action="store_true", help="Create or update deterministic daily roadmap PR with gh")
    p.add_argument("--base-branch", default="main", help="Base branch for PR")
    p.add_argument("--branch-prefix", default="codex/roadmap-daily", help="Deterministic branch prefix")
    p.add_argument("--only", default="", help="Optional CSV list of skills to scope rollup + PR narrative")
    p.add_argument("--skip-pr-if-no-change", action="store_true", help="Skip PR create/update when roadmap artifacts have no staged changes")
    p.add_argument("--dry-run", action="store_true", help="Do not commit/push/create PR; only report planned PR actions")
    p.add_argument("--json", action="store_true", help="Emit JSON")
    return p.parse_args(argv)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    repo_root = Path(args.repo_root).expanduser().resolve()
    output_dir = Path(args.output_dir).expanduser() if args.output_dir else repo_root / "data" / "roadmap"

    try:
        report = run(
            repo_root,
            output_dir,
            open_pr=bool(args.open_pr),
            base_branch=str(args.base_branch),
            branch_prefix=str(args.branch_prefix),
            dry_run=bool(args.dry_run),
            skip_pr_if_no_change=bool(args.skip_pr_if_no_change),
            only_skills=_parse_csv(str(args.only)),
            releases_override=Path(args.releases).expanduser().resolve() if args.releases else None,
            events_override=Path(args.events).expanduser().resolve() if args.events else None,
            stamp_override=str(args.stamp),
        )
    except RoadmapPrepError as err:
        print(f"error: {err}", file=sys.stderr)
        return 1

    if args.json:
        print(json.dumps(report, indent=2))
    else:
        print(f"rollup_path: {report['rollup_path']}")
        print(f"summary_md_path: {report['summary_md_path']}")
        print(f"open_pr_mode: {report['open_pr']['mode']}")
        print(f"open_pr_url: {report['open_pr']['url']}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
